package plugins

import (
	"fmt"
	"github.com/petomalina/mirror/pkg/cp"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"math/rand"
	"os"
	"os/exec"
	"path/filepath"
	"plugin"
	"reflect"
	"regexp"
	"unsafe"

	. "github.com/petomalina/mirror/pkg/logger"
)

var (
	pkgRegex = regexp.MustCompile(`(?m:^package (?P<pkg>\w+$))`)
)

// Build builds the given package into plugin and saves it in
// current path under a random name .so, returning the name to the caller
func Build(pkg string, out string) (string, error) {
	L.Method("Internal/plugin", "Build").Trace("Invoked with pkg: ", pkg)
	// random file name so we'll get unique plugins each time
	uniq := rand.Int()

	objPath := filepath.Join(out, fmt.Sprintf("%d.so", uniq))
	L.Method("Bundle", "Run").Trace("Object path: ", objPath)

	// create the plugin from the passed package
	err := WithChangedPackage(pkg, "main", func() error {
		cmd := exec.Command("go", "build", "-buildmode=plugin", "-o="+objPath, pkg)
		cmd.Stderr = os.Stderr
		cmd.Stdout = os.Stdout
		return cmd.Run()
	})

	return objPath, err
}

// LoadSymbols accepts a plugin path and returns all symbols
// that were found in the given plugin.
// If * is provided as only value in `symbols`, all symbols from the
// given plugin will be returned
func LoadSymbols(pluginPath string, symbols []string) ([]interface{}, error) {
	p, err := plugin.Open(pluginPath)
	if err != nil {
		return nil, err
	}

	// special case - load all exported symbols from the file
	if len(symbols) == 1 && symbols[0] == "all" {
		L.Method("Internal/plugin", "LoadSymbols").Trace("Got 'all' option, finding symbols")
		// clear the symbols array so it doesn't contain the *
		symbols = []string{}

		// create the reflection from the 'syms' field of Plugin
		symsField := reflect.ValueOf(p).Elem().FieldByName("syms")
		// create an unsafe pointer so we can access that field (disables the runtime protection)
		symsFieldPtr := reflect.NewAt(symsField.Type(), unsafe.Pointer(symsField.UnsafeAddr())).Elem()

		// range through the map and create the symbols in our array
		for sym := range symsFieldPtr.Interface().(map[string]interface{}) {
			symbols = append(symbols, sym)
		}
	}

	L.Method("Internal/plugin", "LoadSymbols").Trace("Looking up symbols: ", symbols)
	// add model symbols that were loaded from the built plugin
	models := []interface{}{}
	for _, symName := range symbols {
		sym, err := p.Lookup(symName)
		if err != nil {
			return nil, err
		}

		models = append(models, sym)
	}

	return models, nil
}

// WithChangedPackage changes the `package X` line of each file in the
// targeted package, changing its name to the desiredPkgName, running the
// `run` function and changing it back to the default
func WithChangedPackage(pkgName, desiredPkgName string, run func() error) error {
	L.Method("Internal/package", "WithChangedPackage").Trace("Invoked on pkgName: ", pkgName)
	pkg, err := FindPackage(pkgName)
	if err != nil {
		return err
	}

	// replace all package directives to the desired package names
	for _, f := range pkg.GoFiles {
		// read the go file first
		bb, err := ioutil.ReadFile(f)
		if err != nil {
			return err
		}

		// write it back with the replaced package (into the out dir)
		err = ioutil.WriteFile(
			f,
			[]byte(pkgRegex.ReplaceAll(bb, []byte("package "+desiredPkgName))),
			0,
		)

		if err != nil {
			return err
		}
	}

	return run()
}

func GenerateSymbolsForModels(symbolNames []string, out string) ([]string, error) {
	symbolsFile := filepath.Join(out, fmt.Sprintf("/%d.go", rand.Int()))

	tmpl := `// DO NOT EDIT: THIS BLOCK IS AUTOGENERATED BY MIRROR BUNDLE
package main

var (
`

	for _, m := range symbolNames {
		tmpl += "\tX" + m + "  = " + m + "{}\n"
	}

	tmpl += ")\n"

	// mutate to match the symbol prefix
	for i := range symbolNames {
		symbolNames[i] = "X" + symbolNames[i]
	}

	return symbolNames, ioutil.WriteFile(symbolsFile, []byte(tmpl), os.ModePerm)
}

const DefaultCache = ".mirror"

func CopyPackageToCache(pkg *packages.Package, cacheDir string) (string, error) {
	// Copy the directory so the plugin can be build outside
	pkgCacheDir, err := filepath.Abs(filepath.Join(cacheDir, fmt.Sprintf("%d", rand.Int())))
	if err != nil {
		return "", err
	}

	L.Method("Bundle", "Run").Trace("Making cache dir: ", pkgCacheDir)
	err = os.MkdirAll(pkgCacheDir, os.ModePerm)
	if err != nil {
		return "", err
	}

	L.Method("Bundle", "Run").Trace("Copying ", pkg, "->", pkgCacheDir)
	for _, f := range pkg.GoFiles {
		err := cp.File(f, filepath.Join(pkgCacheDir, filepath.Base(f)))
		if err != nil {
			return pkgCacheDir, err
		}
	}

	return pkgCacheDir, nil
}

// FindPackage returns names of go files in the targeted package
func FindPackage(pkg string) (*packages.Package, error) {
	cfg := &packages.Config{
		Mode:  packages.LoadFiles,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, pkg)
	if err != nil {
		return nil, err
	}

	return pkgs[0], nil
}
